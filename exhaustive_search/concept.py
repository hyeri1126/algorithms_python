# 완전 탐색: 정답 가능성 있는 모든 후보를 구하는 것. 
# 1. 재귀 2. 반복문 3. 비트 마스크 
# 완전탐색 최적화에 백트래킹 혹은 dp를 활용할 수 있다.
# 추가개념) DP: 큰 문제를 작은 문제들로 나누어 해결한 후, 그 결과를 저장하여 중복 계산을 줄이는 최적화 기법

# 완전 탐색의 기본 문제 유형
# 1. [4,9,7,5,1]에서 세 개의 숫자를 더해서 17가 될 수 있나요? (중복x) -> 모든 경우의 수를 구해야함, backtrack 활용 X
# 2. word search; 가로 또는 세로로 이어서 "CAT"이라는 글자를 만들어 주세요. -> backtracking 활용
# 3. 핸드폰 키패드에서 '4 5 6' 순서대로 입력해서 'kor'를 작성할 수 있나요? 
# 4. [1,2,3,4]로 만들 수 있는 부분집합을 모두 반환하시오 -> 모든 경우의 수를 다 고려해야함. backtracking x
#   -> 그러나 이런 경우는 dp를 사용할 수 있다. 
#   -> 즉, 완전 탐색 중에서 모든 경우의 수를 고려해야하는 경우은 backtraking은 사용하지 못하지만 dynamic programming은 사용할 수 있다. 
# 5. [1,2,3,4]로 만들 수 있는 모든 순열을 반환하시오.
# 6. [1,2,3,4]에서 두 개의 원소를 선택해 만들 수 있는 모든 조합을 반환하시오.
# 7. 출발지에서 도착지까지 최단거리로 도달하는 모든 경우의 수는? -> 이런 경우는 dp로 최적화가 가능하다
#    -> 각 칸에 좌표를 부여. 상태 트리를 생성. 아래로 가거나 오른쪽으로 가거나 두 가지의 선택지가 있음
#    -> 모든 상황을 끝까지 가봐야 답을 알 수 있어서 backtraking 쓸 수 없으나, Dp로 최적화 가능
